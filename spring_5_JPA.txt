---------------------------------------------------------------------Diferencia entre JPA e Hibernate------------------------------------------------------
JPA es una especificacion, propone como implementar un ORM Standar en java, significa api de persistencia de java.

Hibernate es un framework que implementa este estandar, springboot trabaja por defecto con hibernate como proveedor de jpa.
-----------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------Creamos el projecto JPA ------------------------------------------------------------------------------------------------------------------------------------------------------
1º Dependencias, seleccionamos, spring boot devtools, spring data JPA para hibernate, el driver de la BBDD, thymeleaf y spring web y h2 para hacer BBDD automaticas por pereza.

//Creamos la clase Entity
*******************
** Clase Entity  **
*******************
2º Crear la clase entity, utilizar JPA y mapearlo con la BBDD.
	2aº Creamos el package -> com.bolsadeideas.springboot.app.models.entity
	2bº Creamos la clase que va a estar mapeada a la tabla, una clase de JPA, un entity -> Cliente
	2cº Decoramos la clase con @Entity de javax.persistence.Entity
	2dº OPCIONAL, si omitimos la notacion @table la clase se llamara igual que la tabla de la BD.
	2eº Anotamos la clase con @Table, que es para configurar el nombre de la tabla. La nomenclatura aconseja poner el nombre de la tabla en pular y minuscula -> @Table(name="clientes")
	2fº Implementamos serializable en la clase -> implements Serializable
	2gº Implementamos el serialVersionUID(dejando el raton encima y añadir), esto es recomendado porque muchas veces se trabaja con serializacion para almacenarlo y transmitirlo a la memoria -> private static final long serialVersionUID = 4327690299451102763L;
3º Introducimos la clave primaria de tipo long y la forma en la que vamos a generar la clave primaria, por defecto es autoincremental -> 
	@Id
	@GeneratedValue(strategy=GenerationType.IDENTITY)		//En mysql en otracle es .SEQUENCE
	private Long id;

4º Introducimos los demás campos:
	private String nombre;
	private String apellido;
	private String email;

	private Date createAt;

5º Si los nombres de los attributos son distintos a los del campo de la BD podemos indicarlo con @Column, aqui tambien podemos decir si acepta nulos y el largo:
	@Column(name="nombre_cliente")
	private String nombre; 

6º Si tenemos fecha, tenemos que indicar con @Temporal el formato en el que va a guardar este campo en la BBDD y darle formato a la hora de introducirlo con DateTimeFormat.
	@Temporal(TemporalType.DATE)
	@DateTimeFormat(pattern="yyyy-MM-d")
	private Date createAt;

7º Creamos los metodos Getter and Setter.

//Creamos la clase DAO
*******************
**   Clase DAO	 **
*******************
//Esta clase es la de acceso a Datos, se encarga de acceder a los datos y se implementa con JPA a traves del entity.

1º Creamos el package -> com.bolsadeideas.springboot.app.models.dao	, la interfaz en dao -> IClienteDao con este metodo abstracto -> public List<Cliente> findAll();

2º Creamos la clase ClienteDaoImpl y agregamos la interfaz creada.

3º Decoramos la clase con la notacion de @Repository, la cual es una notacion de spring para marcar la clase como componente de acceso a datos. 

4º Ponemos el entityManager el cual se encarga de manejar las clases de entidades, persiste su ciclo de vida y puede realizar consultas, actualizarlas, elimiarlas es decir todas las operaciones de la BD pero a nivel de objeto a travs de las clases entity JPA .
Van a la clase entity no a la tabla, la clase esta mapeada a la tabla:
	private EntityManager em;

5º Para hacer una consulta aprovechando el metodo que retorna una lista:

	@SuppressWarnings("unchecked")		//Debido a que da un warning inofensivo lo suprimimos
	@Transactional(readOnly=true)		//Esta notacion sirve para que sea de solo lectura al ser solo una consulta, si fuese un insert (persist) podemos omitirlo, el import ha de ser de springframework
	@Override
	public List<Cliente> findAll() {
		
		return em.createQuery("from Cliente").getResultList();			//Realizamos una consulta con createQuery que retorna el listado cliente
	}

6º Inyectamos el entityManager con la anotacion @PersistenceContext. Lo hace de forma automatica si no configuramos ningun tipo de bd en el application properties. En este ejemplo usara h2 embedida en nuestra app.
	@PersistenceContext
	private EntityManager em;

//Creamos la clase controladora con el handler listar
******************
**  Controlador	**
******************
1º Creamos el package controllers y la clase ClienteController, decorandola con @Controller.

2º Creamos el metodo listar con el getMapping, inyectamos la interfaz y pasamos los datos a la vista:
	@Controller
	public class ClienteController {
	
		@Autowired							//Con esta anotación va a buscar un componente registrado en el contenedor que implemente la interfaz cliente dao, busca un BEANS.
		@Qualifier("clienteDaoJPA")
		private IClienteDao clienteDao;		//Siempre ha de ser el tipo más generico, en este caso la interfaz
	
		@GetMapping("/listar")
		public String listar(Model model) {
			model.addAttribute("titulo", "Listado de clientes");
			model.addAttribute("clientes", clienteDao.findAll());	//Pasamos el listado de clientes a la vista
			return "listar";
		}
	}

//Creamos la vista listar
*****************
**   Vista     **
*****************
1º Creamos listar.html en templates:
	<!DOCTYPE html>
	<html xmlns:th="http://www.thymeleaf.org">
	<head>
	<meta charset="UTF-8"/>
	<title th:text="${titulo}"></title>
	</head>
	<body>
	<h1 th:text="${titulo}"></h1>

	<table>
		<thead></thead>
			<tr>
				<th>id</th>
				<th>nombre</th>
				<th>apellido</th>
				<th>email</th>
				<th>fecha</th>
			</tr>
		<tbody><!-- Iteramos por cada objeto cliente dentro del objeto que hemos pasado -->
			<tr th:each="cliente: ${clientes}">
				<td th:text="${cliente.id}"></td>
				<td th:text="${cliente.nombre}"></td>
				<td th:text="${cliente.apellido}"></td>
				<td th:text="${cliente.email}"></td>
				<td th:text="${cliente.createAt}"></td>
			</tr>
		</tbody>
	</table>
	</body>
	</html>

**************************
**  Archivo Import Sql  **
**************************
//Creamos un archivo import en recursos de tipo file con los datos de prueba al no tener una BBDD.
//IMPORTANTE llamarlo import.sql

Contenido del import.sql ->
	/* Populate tables */
INSERT INTO clientes (id, nombre, apellido, email, create_at) VALUES(1, 'Andres', 'Guzman', 'profesor@bolsadeideas.com', '2017-08-28');
INSERT INTO clientes (id, nombre, apellido, email, create_at) VALUES(2, 'Jhohn', 'Doe', 'john.doe@gmail.com', '2017-08-28');
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------- Consola H2 Database de springboot --------------------------------------------------------------
//En la url -> h2-console

//En el properties o yml -> spring.h2.console.enabled=true

//Por defecto la BD es el que te diga en la consola al arrancar la app en la linea de available, ejemplo  jdbc:h2:mem:31741281-35bd-4083-a507-f9e0490c972a y el usuario sa sin clave.

//Podemos introducir la conexion manual en el .properties:
	spring.datasource.url=jdbc:h2:mem:clientesdb
	spring.datasource.username=andres
	spring.datasource.password=sa
	spring.datasource.driver-class-name=org.h2.Driver
	spring.h2.console.enabled=true
----------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------Agregando crear en repositorio Dao y controlador ---------------------------------------------
*********************************************
**    Crear un nuevo registro con JPA.     **
*********************************************

1º Agregamos el metodo para poder crear en la interfaz dl cliente, pura buenas practicas -> public void save(Cliente cliente);

2º Implementamos el metodo en la clase Dao, mediante persist con ayuda del entity manager:
	@Transactional
	@Override
	public void save(Cliente cliente) {
		em.persist(cliente);
	}

3º Implementamos el metodo GetMapping para pasar el objeto Usuario al formulario y despues con el GetPost lo creamos con los datos del form:

	@GetMapping("/form")
	public String crear(Model model) {		
		Cliente cliente = new Cliente();		
		model.addAttribute("cliente",cliente);
		model.addAttribute("titulo", "Formulario de cliente");
		return "form";
	}
	@PostMapping("/form")
	public String guardar(Cliente cliente) {	//Recibe el objeto cliente que viene con los datos poblados y lo guarda
		clienteDao.save(cliente);
		return("redirect:listar");
	}

4º Vista form.html: Importante tener un input hidden con el id -> <input type="hidden" th:field="*{id}"> 

5º Agregamos un metodo en el cliente prePersist, antes de que se guarde en la BBDD la fecha justo antes de invocar el persist (para guardar en la BD), con la anotacion @PrePersist:
	@PrePersist
	public void prePersist() {		//Se ejecuta justo antes de que se guarde en la base de datos
		createAt = new Date();		//Pone la fecha actual
	}

----------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------  Agregando Editar en BD  ------------------------------------------------------------------------
1º Modificamos la interfaz IClienteDato -> public Cliente findOne(Long id);

2º Añadimos el metodo en CLienteDao:
	@Override
	@Transactional(readOnly=true)
	public Cliente findOne(Long id) {			//Editar, retorna el id para que podamos editar en ese id en concreto
		return em.find(Cliente.class, id);
	}

3º Añadimos el metodo en el controlador:
	@RequestMapping(value="/form/{id}")					//Editar, @pathvariable es para pasarle el id mediante la url
	public String editar(@PathVariable(value="id") Long id, Model model) {
		Cliente cliente = null;
		
		if(id>0) {
			cliente = clienteDao.findOne(id);
		}else {
			return "redirect://listar";	//Redirijimos por seguridad si es igual a 0			
		}
		model.addAttribute("cliente", cliente);
		model.addAttribute("titulo", "Editar Cliente");
		return "form";
	}
4º Añadimos en link a la vista del controlador en la vista form, se le pasa la ruta + el id que hemos recogido, por eso lo del requestMapping:
	<td><a th:href="@{/form/} + ${cliente.id}" th:text="'Editar'" class="btn btn-primary btn-x"></a></td>

5º Ahora añadimos un mecanismo en el controlador, para ello modificamos el metodo save del ClienteDaoImpl.java y segun el id hara una cosa u otra, para insertar si el id en la vista form no existe o es igual a 0 o editar si es mayor que 0:
	@Transactional
	@Override
	public void save(Cliente cliente) {	//Crear
		if(cliente.getId() != null && cliente.getId() > 0) {	//Si es nulo el id y es mayor que 0 significa que estamos editando, por lo tanto editaremos y no crearemos de 0
			em.merge(cliente);			//Merge actualiza un objeto ya existente
		}else {
			em.persist(cliente);		//Persist crea un objeto en la bd
		}				
	}

//Otra forma de editar mas segura, es quitar el input hidden id en el form, crear una session en el controlador guardando el objeto cliente y pasarla a la vista, una vz ejecutado el metodo guardar del post en la bd, eliminar la session.
	@Controller
	@SessionAttributes("cliente")
	public class ClienteController {
	................. Codigo
	@PostMapping("/form")		//Guardamos en la bd
	public String guardar(Cliente cliente, SessionStatus status) {	//Recibe el objeto cliente que viene con los datos poblados y lo guarda
		clienteDao.save(cliente);
		status.setComplete();		//Eliminamos el objeto guardado en la sesion al editar o crear
		return("redirect:listar");
	}
	//Fin Crear

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


--------------------------------------------------------------------------------------------- Agregando Eliminar ------------------------------------------------------------------------
1º Añadimos el metodo en la Interfaz IClienteDao -> public void delete(Long id);

2º Añadimos el metodo en el ClienteDaoImpl:
	@Override
	@Transactional
	public void delete(Long id) {		//Eliminar, obtenemos el cliente por el id y lo eliminamos.
		Cliente cliente = findOne(id);
		em.remove(cliente);
	}
3º Añadimos el metodo para eliminar en el controlador:
	@RequestMapping(value="/eliminar/{id}")					//Eliminar
	public String eliminar(@PathVariable(value="id") Long id) {
		
		if(id > 0) {	
			clienteDao.delete(id);
		}
		
		return "redirect:/listar";	//Lo elimina y retorna a la vista
	}

4º Añadimos el enlace a la vista, con el evento para confirmar el eliminar:
	<td><a th:href="@{/eliminar/} + ${cliente.id}" th:text="'Eliminar'" onclick="return confirm('Estás seguro que quieres eliminar?');" class="btn btn-danger btn-xs"></a></td>
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------- Agregar la capa Service ------------------------------------------------------------------------------------------
//Una clase Service, no es más que una clase que presta servicio de lógica de negocio al controlador, el 99% de las veces son clases que contienen como atributos los objetos DAOs para realizar consultas y operaciones con JPA.
//Lo que hace es, realizar operaciones y select a la base de datos, usando los objetos dao.
//Esto permite centralizar en una única clase o fachada varios Dao que pueden trabajar en conjunto bajo la misma transacción  realizando varias consultas u operaciones de diferentes DAO en un solo método del service o de forma independiente. Así evitamos ensuciar el controlador con múltiples accesos a DAO.
//Más que nada es un patron de diseño que desacopla el Dao del controlador y lo deja en una clase más especializada, pero es opcional, igual puedes usar los Daos directamente en el controlador, pero si estás trabajando con muchos Dao puede tornarse un poco desordenado.


1º Creamos el package service y dentro la interfaz IClienteService y la clase ClienteServiceImpl.

2º La idea es que por cada metodo en la clase dao vamos a tener metodos en la clase service:

	public interface IClienteService {
	
		public List<Cliente> findAll();
	
		public void save(Cliente cliente);
	
		public Cliente findOne(Long id);
	
		public void delete(Long id);
	}

3º Implementamos los metodos en la clase ClienteServiceImpl, inyectando el cliente DAO. Con estos metodos usaremos los metodos del cliente DAO, es como una fachada, sirve para desacoplar el Dao  del controlador como patron de diseño.
	@Service
	public class ClienteServiceImpl implements IClienteService {
	
		@Autowired
		private IClienteDao clienteDao;

		@Override
		public List<Cliente> findAll() {
			return clienteDao.findAll();
		}

		@Override
		public void save(Cliente cliente) {
			clienteDao.save(cliente);
		}

		@Override
		public Cliente findOne(Long id) {
			return clienteDao.findOne(id);
		}

		@Override
		public void delete(Long id) {
			clienteDao.delete(id);
		}

	}

4º Gracias a manejarlo desde la clase service, podemos quitar las anotaciones @Transactional en el Dao, moviendo todos los transaccionals a la clase service en su correspondiente metodo.
//Dentro de un metodo de la clase service podemos interactuar con diferentes Dao dentro de la misma transaccion, esa es la idea de esto.

5º Cambiamos la inyeccion del controlador del IClienteDao al IClienteService -> private IClienteService clienteService;

//Este patro de diseño se llama Facade, es una practica recomendada en vez de implementar los Dao de forma directa en el controlador.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------ Implementando el Dao con la interface CrudRepository ---------------------------------------------------------------------
//Con esto podemos implementar nuestro componente de acceso a datos Dao con la interfaz CrudRepository, la cual es propia del Api de Spring Data Jpa.

//Documentacion: https://spring.io/projects/spring-data
https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories

Los metodos para utilizar van construidos por debajo de la interfaz.

//Esto es como lo hice anteriormente, pero de forma automatica.

//Puede heredad de CrudRepository o de JpaRepository, la diferencia es que Jpa incluye otros metodos, por ejemplo para paginacion, ordenamiento...

//Las consultas personalizadas hay que tener cuidado porque son a nivel de objeto no a nivel de tablas, por lo tanto no vale la sintaxis sql.

//Tambien se pueden usar nombres de metodos para las query pero con ciertas reglas, por ejemplo findBy'Atributo'And|Or'Atributo', pongo una comparacion a continuacion:
	List<User> findByEmailAddressAndLastname(String emailAddress, String lastname = select u from User u where u.emailAddress = ?1 and u.lastname = ?2

***********************************************************
**	Modificar el proyecto con un ejemplo de esto     **
***********************************************************
1º Eliminamos Cliente DaoImpl porque la idea es modificar la interfaz Dao y limpiamos los metodos de nuestra interfaz Dao.

2º Convertimos nuestra interfaz  ICLienteDao.java en el crudRepository:
	public interface IClienteDao extends CrudRepository<Cliente, Long>{
		//Como primer parametro el tipo de dato de nuestra clase Entity y como segundo parametro el tipo de la key (id)
		//No hace falta anotarla como @Repository para inyectarla debido a que es una interfaz especial, que hereda de CrudRepository, por debajo ya es un componente Spring, no es necesario indicarlo con anotaciones
	}

3º Ahora tenemos que modificar el ClienteServiceImpl para que use los metodos de el repository:
	@Service
	public class ClienteServiceImpl implements IClienteService {

		@Autowired
		private IClienteDao clienteDao;

		@Override
		@Transactional(readOnly = true)
		public List<Cliente> findAll() {
			return (List<Cliente>) clienteDao.findAll();
		}

		@Override
		@Transactional
		public void save(Cliente cliente) {
			clienteDao.save(cliente);
		}

		@Override
		@Transactional(readOnly = true)
		public Cliente findOne(Long id) {
			return clienteDao.findById(id).orElse(null);
		}

		@Override
		@Transactional
		public void delete(Long id) {
			clienteDao.deleteById(id);
		}

	}
//Es una forma mucho más simple y más facil de trabajar con Jpa.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------- Cambiando H2(Datasource) a Mysql---------------------------------------------------------------------------------------------
*****************************************
**   Conexion application.properties   **
*****************************************
spring.datasource.url=jdbc:mysql://localhost/db_springboot
spring.datasource.username=root
spring.datasource.password=Chun1ni995.
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.jpa.database-platform=org.hibernate.dialect.MySQL8Dialect

//Podemos añadir la siguiente linea para hacer pruebas, a efecto de probar y desarrollar y crear las tablas a traves de los @entity y cuando paramos la aplicacion las elimina por completo e importa lo del import.sql que tengamos:
spring.jpa.hibernate.ddl-auto=create-drop

//Linea para que nos muestre las consultas nativas que genera jpa por debajo:
logging.level.org.hibernate.SQL=debug

//Si nos da error de servertimezone modificamos la primera linea -> spring.datasource.url=jdbc:mysql://localhost/db_springboot?serverTimezone=Europe/Madrid&UseSSL=false
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------ Mensaje despues de guardar, eliminar o lo que sea, Flash Messenger ------------------------------------------------
1º Añadimos RedirecAttributes flash en el metodo del controlador que queramos:
	@PostMapping("/form")		//Guardamos en la bd
	public String guardar(Cliente cliente, SessionStatus status, RedirectAttributes flash) {
		flash.addAttribute("success", "Cliente Creado con exito!");

2º En el html lo manejamos segun el mensaje.
	
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------- Paginacion para BBDD Jpa-------------------------------------------------------------------------------
//Es importante cuando la cantidad de registros es importante, mejoramos el rendimiento ya que no traemos todos los registros a la vez.

1º En el repository tenemos que extender de PagingAndSortingRepository:
	public interface IClienteDao extends PagingAndSortingRepository<Cliente, Long>{}

2º En el IClienteService, añadimos un nuevo metodo, Pageable lo importamos del springframework...domain:
	public Page<Cliente> findAll(Pageable pageable);		//Retorna un page que es un iterable

3º En el ClienteService importamos el metodo y lo modificamos:
	@Override
	public Page<Cliente> findAll(Pageable pageable) {
		return clienteDao.findAll(pageable);
	}

4º En el controlador implementamos la paginacion, antes estabamos recibiendo todos los registros, ahora con esto no:
	4aº Obtenemos la pagina actual mediante la ruta url con @RequestParam()
		@GetMapping("/listar")					//Pasamos el listado de clientes a la vista
		public String listar(@RequestParam(name="page", defaultValue="0") int page, Model model) {
		
			Pageable pageRequest = PageRequest.of(page, 5);		//Mostramos 4 registros por pagina, se pueden colocar los que quieras
		
			Page<Cliente> clientesPaginacion = clienteService.findAll(pageRequest);		//Invocamos el listar todo pero paginable del service
		
			PageRender<Cliente> pageRender = new PageRender<>("/listar", clientesPaginacion);
			model.addAttribute("titulo", "Listado de clientes");
			model.addAttribute("clientes", clientesPaginacion);			//Pasamos el cliente paginado
			model.addAttribute("page", pageRender);
			return "listar";
		}

5º Hay que crear una clase que calcule desde donde hasta donde y a medida que vamos avanzando va corriendo hata los ultimos registros, o retrocediendo, creamos el package com.bolsadeideas.springboot.app.paginator y la clase PageRender, para calcular como se gestionan los registros por pagina y mostrarlos todos:
public class PageRender<T> {
	private String url;
	private Page<T> page;

	private int totalPaginas;

	private int numElementosPorPagina;

	private int paginaActual;

	private List<PageItem> paginas;
	
	public PageRender(String url, Page<T> page) {
		this.url = url;
		this.page = page;
		this.paginas = new ArrayList<PageItem>();

		numElementosPorPagina = page.getSize();
		totalPaginas = page.getTotalPages();
		paginaActual = page.getNumber() + 1;

		int desde, hasta;
		if (totalPaginas <= numElementosPorPagina) {
			desde = 1;
			hasta = totalPaginas;
		} else {
			if (paginaActual <= numElementosPorPagina / 2) {
				desde = 1;
				hasta = numElementosPorPagina;
			} else if (paginaActual >= totalPaginas - numElementosPorPagina / 2) {
				desde = totalPaginas - numElementosPorPagina + 1;
				hasta = numElementosPorPagina;
			} else {
				desde = paginaActual - numElementosPorPagina / 2;
				hasta = numElementosPorPagina;
			}
		}
		for(int i=0 ; i < hasta; i++) {
			paginas.add(new PageItem(desde + i, paginaActual == desde + i));
		}
	}

	public String getUrl() {
		return url;
	}

	public int getTotalPaginas() {
		return totalPaginas;
	}
	public int getPaginaActual() {
		return paginaActual;
	}

	public List<PageItem> getPaginas() {
		return paginas;
	}
	
	public boolean isFirst() {
		return page.isFirst();
	}
	
	public boolean isLast() {
		return page.isLast();
	}
	
	public boolean isHasNext() {
		return page.hasNext();
	}
	
	public boolean isHasPrevious() {
		return page.hasPrevious();
	}
}

6º  Faltaria crear una clase para representar cada una de las paginas, tendra el numero de pagina e indicara si es el numero actual. Creamos la clase PageItem:
	public class PageItem {
	private int numero;
	private boolean actual;
	
	public PageItem(int numero, boolean actual) {	
		this.numero = numero;
		this.actual = actual;
	}

	public int getNumero() {
		return numero;
	}

	public boolean isActual() {
		return actual;
	}
	
}

7º Crear la el fragmento html del paginador:
	<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<body>

	<nav th:fragment="paginator">

		<ul class="pagination">
			<li class="page-item"
				th:class="${page.first? 'page-item disabled': 'page-item'}"><span
				class="page-link" th:if="${page.first}">Primera</span> <a
				class="page-link" th:if="${not page.first}"
				th:href="@{${page.url}(page=0)}">Primera</a></li>


			<li class="page-item"
				th:class="${not page.hasPrevious? 'page-item disabled': 'page-item'}">
				<span class="page-link" th:if="${not page.hasPrevious}">&laquo;</span>
				<a class="page-link" th:if="${page.hasPrevious}"
				th:href="@{${page.url}(page=${page.paginaActual-2})}">&laquo;</a>
			</li>

			<li class="page-item" th:each="item : ${page.paginas}"
				th:class="${item.actual? 'page-item active': 'page-item'}"><span
				class="page-link" th:if="${item.actual}" th:text="${item.numero}"></span>
				<a class="page-link" th:if="${not item.actual}"
				th:href="@{${page.url}(page=${item.numero-1})}"
				th:text="${item.numero}"></a></li>


			<li class="page-item"
				th:class="${not page.hasNext? 'page-item disabled': 'page-item'}">
				<span class="page-link" th:if="${not page.hasNext}">&raquo;</span> <a
				class="page-link" th:if="${page.hasNext}"
				th:href="@{${page.url}(page=${page.paginaActual})}">&raquo;</a>
			</li>

			<li class="page-item"
				th:class="${page.last? 'page-item disabled': 'page-item'}"><span
				class="page-link" th:if="${page.last}">&Uacute;ltima</span> <a
				class="page-link" th:if="${not page.last}"
				th:href="@{${page.url}(page=${page.totalPaginas-1})}">&Uacute;ltima</a>
			</li>
		</ul>

	</nav>

</body>
</html>	
------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------- Asociaciones ManyToOne Bidireccional -----------------------------------------------------
//Clases entity factura y cliente, el client epuede tener muchas facturas y la factura aun cliente, por ello many to one
1º Creamos la clase factura y la mapeamos como entity:
	@Entity
	@Table(name="facturas")
	public class Factura implements Serializable {
		/**
		 * 
		 */	
		@Id
		@GeneratedValue(strategy=GenerationType.IDENTITY)
		private static final long serialVersionUID = 1L;

		private Long id;
		private String descripcion;
		private String observacion;
	
		@Temporal(TemporalType.DATE)
		@Column(name="create_at")
		private Date createAt;
		private Cliente cliente;

		public Long getId() {
			return id;
		}

		public void setId(Long id) {
			this.id = id;
		}

		public String getDescripcion() {
			return descripcion;
		}

		public void setDescripcion(String descripcion) {
			this.descripcion = descripcion;
		}

		public String getObservacion() {
			return observacion;
		}

		public void setObservacion(String observacion) {
			this.observacion = observacion;
		}

	public Date getCreateAt() {
		return createAt;
	}

	public void setCreateAt(Date createAt) {
		this.createAt = createAt;
	}

	public Cliente getCliente() {
		return cliente;
	}

	public void setCliente(Cliente cliente) {
		this.cliente = cliente;
	}

}

2º En la clase cliente que ya teniamos añadimos el atributo facturas:
	private List<Factura> facturas;

	public Cliente() {					
		facturas = new ArrayList<Factura>();
	}

	...

	public List<Factura> getFacturas() {
		return facturas;
	}

	public void setFacturas(List<Factura> facturas) {
		this.facturas = facturas;
	}

	public void addFactura(Factura factura) {		//Este es opcional
		facturas.add(factura);
	}

3º Mapeamos facturas con clientes con la anotacion, @ManyToOne, ya que las facturas son muchas para un cliente, lo de 1:M y eso:
//Indicamos el tipo de fetch, con LAZY, ya que el EAGER trae todo de una sola vez, con lazy se realizan de forma perezosa a medida que se van invocando los metodos, para obtener los datos
	@ManyToOne(fetch=FetchType.LAZY)
	private Cliente cliente;

4º Mapeamos clientes con facturas, con la anotacion, @OneToMany, ya que los clientes son uno para muchas facturas.
	@OneToMany(mappedBy="cliente", fetch=FetchType.LAZY, cascade=CascadeType.ALL)	//Aqui la carga perezosa es con más razón, ya que llamaria a todas las facturas de cada cliente y no vamos a mostrar todas esas facturas, asi que lo ideal es ir cargandolas segun se necesita
	private List<Factura> facturas;
	//cascade=CascadeType.ALL, significa que todas las operaciones delete y persist se van a realizar en cadena, por ejemplo si el cliente se elimina se elimina de forma automatica a todas sus facturas, todos sus elementos hijos.
	//mappedBy="cliente" Le asignamos el atributo de la otra clase de la relacion (en este caso como se llama el id cliente en facturas), con esto hacemos que sea bidireccional, de forma automatica va a crear la llave foranea cliente id en la tabla facturas.

5º Creamos la clase ItemFactura y por lo tanto el atributo ItemFactura en factura, el cual sera una lista, en este caso al no ser bidireccional la relacion Factura-
-ItemFactura debemos hacer el @JoinColumn(name="factura_id") para indicar cual es la clave foranea en item_factura, que ademas sera un atributo de esta. En cliente al ser bidireccional lo hace con el mapped (esta en el cliente)
	@OneToMany(fetch=FetchType.LAZY, cascade=CascadeType.ALL)
	@JoinColumn(name="factura_id")
	private List<ItemFactura> items;
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------- Listar Factura en vista --------------------------------------------------------------------------------------------------------------------------------------------------------------
//En la vista ver.html
			<div th:if="${#lists.isEmpty(cliente.facturas)}"
				class="aler alert-info my-4"
				th:text="'No hay facturas asignadas para el cliente ' + ${cliente.nombre} + ' ' + ${cliente.apellido}"></div>
			<table th:if="${not #lists.isEmpty(cliente.facturas)}"
				class="table table-bordered table-striped my-4">
				<thead class="thead-dark">
					<tr>
						<th>folio</th>
						<th>descripcion</th>
						<th>fecha</th>
						<th>total</th>
					</tr>
				</thead>
				<tbody>
					<tr th:each="factura: ${cliente.facturas}">
						<td th:text="${factura.id}"></td>
						<td th:text="${factura.descripcion}"></td>
						<td th:text="${factura.createAt}"></td>
						<td th:text="${factura.total}"></td>		<!-- factura.total es un metodo publico y retorna total, por lo tanto lo coje del get -->
					</tr>
				</tbody>
			</table>

//Clase Factura
	@Entity
@Table(name = "facturas")
public class Factura implements Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long id;
	private String descripcion;
	private String observacion;

	@Temporal(TemporalType.DATE)
	@Column(name = "create_at")
	private Date createAt;

	@ManyToOne(fetch=FetchType.LAZY)
	private Cliente cliente;

	@OneToMany(fetch=FetchType.LAZY, cascade=CascadeType.ALL)
	@JoinColumn(name="factura_id")
	private List<ItemFactura> items;
	
	@PrePersist
	public void prePersist() { // Se ejecuta justo antes de que se guarde en la base de datos
		createAt = new Date();
	}
	
	public Factura() {
		this.items = new ArrayList<ItemFactura>();
	}



	public void addItemFactura(ItemFactura item) {
		this.items.add(item);
	}
	
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getDescripcion() {
		return descripcion;
	}

	public void setDescripcion(String descripcion) {
		this.descripcion = descripcion;
	}

	public String getObservacion() {
		return observacion;
	}

	public void setObservacion(String observacion) {
		this.observacion = observacion;
	}

	public Date getCreateAt() {
		return createAt;
	}

	public void setCreateAt(Date createAt) {
		this.createAt = createAt;
	}

	public Cliente getCliente() {
		return cliente;
	}

	public void setCliente(Cliente cliente) {
		this.cliente = cliente;
	}

	public List<ItemFactura> getItems() {
		return items;
	}

	public void setItems(List<ItemFactura> items) {
		this.items = items;
	}

	public Double getTotal() {
		Double total = 0.0;
		
		int size = items.size();
		for(int i= 0; i<size; i ++) {
			total += items.get(i).calcularImporte();
		}
		return total;
	}
	
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------- Controlador Clase factura con handler crear ------------------------------------------------------------------------------------------------------------------------------------
@Controller
@RequestMapping("/factura")
@SessionAttributes("factura")	//Mantenemos el objeto factura hasta que se guarde en el form
public class FacturaController {
	
	@Autowired
	private IClienteService clienteService;
	
	@GetMapping("/form/{clienteId}")		//IMPORTANTE AQUI VEMOS EJEMPLO CON EL GETMAPPING TB {id}
	public String crear(@PathVariable(value="clienteId") Long clienteId, Model model, RedirectAttributes flash) {
		
		Cliente cliente = clienteService.findOne(clienteId);	//Necesitamos el cliente para dar de alta la factura
		if(cliente == null) {
			flash.addAttribute("error", "El cliente no existe en la bse de datos");
			return "redirect:/listar";
		}
		
		Factura factura = new Factura();
		factura.setCliente(cliente);
		
		model.addAttribute("factura", factura);
		model.addAttribute("titulo", "Crear Factura");
		return "form";
	}
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------ Form Factura Vista -------------------------------------------------------------------------------------------------------------------------------------------------------
<body>

	<header>
		<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
			<div class="container-fluid">
				<a class="navbar-brand" href="#">Spring Boot</a>
				<button class="navbar-toggler" type="button"
					data-bs-toggle="collapse" data-bs-target="#navbarNav"
					aria-controls="navbarNav" aria-expanded="false"
					aria-label="Toggle navigation">
					<span class="navbar-toggler-icon"></span>
				</button>
				<div class="collapse navbar-collapse" id="navbarNav">
					<ul class="navbar-nav">
						<li class="nav-item"><a class="nav-link active"
							aria-current="page" href="#">Home</a></li>
						<li class="nav-item"><a class="nav-link" th:href="@{/listar}">Clientes</a>
						</li>
					</ul>
				</div>
			</div>
		</nav>
		<div class="alert alert-success" th:if="${success != null}"
			th:text="${sucess}"></div>
		<div class="alert alert-danger" th:if="${error != null}"
			th:text="${error}"></div>
		<div class="alert alert-warning" th:if="${warning != null}"
			th:text="${warning}"></div>
		<div class="alert alert-info" th:if="${info != null}"
			th:text="${info}"></div>
	</header>
	<div class="container">
		<form th:action="@{/factura/form/}" th:object="${factura}"
			method="post">
			<div class="form-group row">
				<label class="col-sm-2 col-form-label" th:text="'Cliente'"></label>
				<div class="col-sm-6">
					<!-- El input de nombre y apellido es solo lectura, con el disabled, es para mostrar de que cliente es la factura -->
					<input
						th:value="${factura.cliente.nombre} + '' + ${factura.cliente.apellido}"
						class="form-control" disabled='disabled' />
				</div>
				<div class="form-group row">
					<label class="col-sm-2 col-form-label" th:text="'Descripcion'"></label>
					<div class="col-sm-6">
						<input type="text" th:field="*{description}" class="form-control" />
					</div>
				</div>
				<div class="form-group row">
					<label class="col-sm-2 col-form-label" th:text="'Observacion'"></label>
					<div class="col-sm-6">
						<textarea th:field="*{observacion}" class="form-control">/</textarea>
					</div>
				</div>
				<div class="form-group row">
					<div class="col-sm-6">
						<input type="submit" th:value="${titulo}"
							class="btn btn-secondary" />
					</div>
				</div>
		</form>
	</div>
</body>
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

--------------------------------------------------------------------------------------------------- Ajax con jQuery UI para autocompletar -------------------------------------------------------------------------------------------------------------
//Vamos a trabajar con una tarea asincrona para que busque los productos y autocomplete a traves de JQuery con Ajax y vamos a trabajar con el controlador de spring con rest retornando un JSON con los resultados encontrados a medida que vayamos escribiendo las palabras.
//La idea es tener un fragmento en Ajax con Jquery y reutilizarlo

1º Preparamos el proyecto agregando una libreria, link -> https://jquery.com/, descargando y pegando en static js el fichero jquery-3.2.1.min.js 

2º Descargamos el jQuery user interface la version stable -> https://jqueryui.com/

3º Una vez descomprimido, copiamos jquery-ui.min.css y jquery-ui.min.js y lo llevamos al proyecto a static css el css y a static js el js
	
4º En la carpeta que tengamos el fragmento de layout con los estilos copiamos en el head -> <link rel="stylesheet" th:href="@{/css/jquery-ui-mim.css}" />

5º En el footer de la misma ruta ponemos la libre
	<script th:src="@{/js/jquery-3.6.0.min.js}"></script>
		<script th:src="@{/js/popper.min.js}"></script>
		<script th:src="@{/js/bootstrap.min.js}"></script>
		<script th:src="@{/js/jquery-ui.min.js}"></script>
	</footer>
6º Creamos el campo autocomplete para buscar el producto en el form de factura (no esta mapeado al objeto entity solo es un input para poder buscar productos y agregar estos a la factura):
//Este campo va a realizar una peticion asincrona Ajax con jQuery.
	<div class="form-group row">
		<label for="buscar_producto" class="col-sm-2 col-form-label" th:text="'Buscar Producto'"></label>
		<div class="col-sm-6">
			<input type="text" name="buscar_producto" id="buscar_producto" class="form-control"/>
		</div>
	</div>	

7º Creamos una plantilla para el javaScript, creamos el folder js en la carpeta factura y dentro autocomplete-productos.html, el cual sera un fragmento de javaScript:
	<!DOCTYPE html>
	<html xmlns:th="http://www.thymeleaf.org">
	<body>
		<script type="text/javascript" th:fragment="javascript">
		//Nos aseguramos de que el documento html este completamente cargado con el metodo ready
		$(document).ready(function(){
			$("#buscar_producto").autocomplete({
				//Recibe dos objetos
				//El metodo source se encarga de hacer la peticion Ajax
				//El metodo select se encarga de procesar el resultado y hacer algo con los resultados
				source: function(request, response){	//muestra los datos a medida que vamos escribiendo
					$.ajax({
						url:"/factura/cargar-productos/" + request.term,	//es el mapping url para el handler que busca parametros
						dataType: "json",
						data: {
							term:request.term	//Es el termino que estamos introduciendo
						},
						success: function(data){			//Recibe los datos
							response($.map(data, function(item){	//Para pasarlo al autocomplete usamos el responde
								return {		//Por cada item va a retornar el id del producto a traves del item, el label y el precio
									value: item.id,
									label: item.nombre,
									precio: item.precio,
								};
							}));
						},
					});
				},
				select: function(event, ui){	//Se encarga de seleccionar ese valor y hacer alguna tarea
					$("#buscar_producto").val(ui.item.label);  //Pone la seleccion en el campo
					var linea =$("#plantillaItemsFactura").html();		//Llamamos a la plantilla para ir completando la otra tabla de item_factura
					
					linea= linea.replace(/{ID}/g, ui.item.value);		//Reemplazamos los valores
					linea= linea.replace(/{NOMBRE}/g, ui.item.label);
					linea= linea.replace(/{PRECIO}/g, ui.item.precio);
					
					//Ahora cargamos estos valores en la tabla cargar_productos donde los acabaremos usando para crear el item_factura
					$("#cargarItemProductos tbody").append(linea);
					
					return false;
				},
				focus: function(event, ui){		//Para que si nos movemos de las flechas no salga el id
				    event.preventDefault();
				    $('input[name="buscar_producto"]').val(ui.item.label);
				},
			});
		});
		</script>
	</body>
	</html>
8º Lo agregamos al form.html debajo del footer e implementamos el codigo ahi:
	<script th:replace="factura/js/autocomplete-productos :: javascript">

9º Usaremos Jpa para buscar el producto retornado, para eso tenemos que implementar antes las clases repositorio y tal, para eso los siguientes pasos.

10º Creamos el repository en la carpeta de dao como interfaz IProductoDao, a este le meteremos un metodo personalizado para hacer una query like% e ir autocompletando con esa consulta:
//Como esto es una interfaz solo ponemos que tenemos que implementar el metodo sin implementar, lo implementaremos en el service.
	public interface IProductoDao extends CrudRepository<Producto, Long>{
		//Implementamos el metodo personalizado para poder buscar por una query con like% e ir autocompletando con ese like%
	
		//En la query con ?1 hacemos referencia al parametro 1 que hemos metido, es decir, %?1% es = %parametro%
		@Query("select p from Producto p where lower(p.nombre) like %?1%")
		public List<Producto> findByNombre(String term); //Recibira el termino que vamos metiendo e implementamos la consulta con like con la anotacion @Query para modificar y personalizar el metodo
	}

11º Agregamos el metodo en la interface del ClienteService, la cual usara ClienteServiceImpl, por buena practica -> public List<Producto> findByNombre(String term);
 
12º Hay que modificar la clase service, ya que es la que interactua con el controlador y tiene implementado la interfaz con el metodo. Modificamos ClienteServiceImpl. Recordamos que el service es una fachada para trabajar con el repository:
	@Autowired
	private IProductoDao productoDao;		//Inyectamos el repository
	
	@Override
	@Transactional(readOnly = true)				//Implementamos el metodo que usara el controller para introducir el term.
	public List<Producto> findByNombre(String term) {
		return productoDao.findByNombre(term);
	}

13º Hacemos uso de ello en el controller FacturaController:
	@GetMapping(value="/cargar-productos/{term}", produces={"application/json"})	//Debemos poner la url que pusimos en el js del form del autocompletado, con produces genera la salida Json y en la url le pasamos el term tb
	public @ResponseBody List<Producto> cargarProductos(@PathVariable String term){	//@ResponseBody suprime el cargar una vista de thymeleaf y en vez de eso toma el resultado retornado convertido a json y lo puebla dentro  del body en la respuesta
		return productoDao.findByNombre(term.toLowerCase());
	}
!!!!!!NOTA SOLUCION A ERROR -> SI EN EL LAYOUT DONDE TENEMOS EL FOOTER CON LAS LIBRERIAS NO LO INVOCAMOS ANTES DE EL FRAGMENTO NO CARGA LAS LIBRERIAS, tal que asi:
		<footer th:replace="layout/layout :: footer"></footer>
		<script th:replace="factura/js/autocomplete-productos :: javascript"></script>
	</body>
!!!!!Solucion al error 2, si no se ven los estilos del Jquery metemos en el head del form tb: <link rel="stylesheet" th:href="@{/css/jquery-ui.min.css}" />

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------ Crear los items_factura con JQuery ---------------------------------------------------------------------------------------------------------------------------------------------
1º Creamos plantilla-items.html dentro de factura, para reemplazar esta plantilla posteriormente con JQuery y poder servir como un molde/plantilla para poder crear de forma dinamica los items de la factura con JQuery:
	<!DOCTYPE html>
	<html xmlns:th="http://www.thymeleaf.org">
	<body>
	<!-- Es una plantilla oculta con class="d-none", para a traves de Jquery con js leamos la plantilla y reemplacemos los valores. -->
		<table th:fragment="itemsFactura" class="d-none">
			<tbody  id="plantillaItemsFactura">
				<tr id="row_{ID}"><!-- Este valor del id se reemplaza luego con el valor real del itemFactura a traves de JQuery, igual que los otros-->
					<td class="d-none"><input type="hidden" value="{ID}" name="item_id[]"/></td>
					<td>{NOMBRE}</td>
					<td>{PRECIO}</td>
					<td><input type="number" value="1" name="cantidad[]" id="cantidad_{ID}" class="form-control col-sm-4"/></td>
				</tr>
			</tbody>
		</table>
	</body>
	</html>

2º Nos vamos a form.html de factura y agregamos la plantilla justo debajo del campo buscar producto -> <table th:replace="factura/plantilla-items :: itemsFactura"></table>

3º Creamos los items de la factura, para ello justo debajo de la plantilla hacemos una tabla que va a contener todos los items y se va a ir rellenando de forma dinamica cuando se selecciona un producto del autocomplete con JQuery:
	<table id="cargarItemProductos" class="table table-sm table-striped table-hover">
		<thead>
			<tr>
				<th>Nombre</th>
				<th>Precio</th>
				<th>Cantidad</th>
			</tr>							
		</thead>
		<tbody>
		</tbody>
	</table>

4º Ahora en el autocompleteproductos donde ibamos mostrando los productos autocompletando en el select, introducimos el codigo necesario para con los seleccionados ir introduciendolos.
//Tenemos que ir a buscar el contenido de la plantilla-items.html y reemplazar los valores, para ello el modificamos el autocomplete-productos.html, la funcion select:

				select: function(event, ui){	//Se encarga de seleccionar ese valor y hacer alguna tarea
					$("#buscar_producto").val(ui.item.label);  //Pone la seleccion en el campo
					var linea =$("#plantillaItemsFactura").html();		//Llamamos a la plantilla para ir completando la otra tabla de item_factura
					
					linea= linea.replace(/{ID}/g, ui.item.value);		//Reemplazamos los valores
					linea= linea.replace(/{NOMBRE}/g, ui.item.label);
					linea= linea.replace(/{PRECIO}/g, ui.item.precio);
					
					//Ahora cargamos estos valores en la tabla cargar_productos donde los acabaremos usando para crear el item_factura
					$("#cargarItemProductos tbody").append(linea);
					
					return false;
				},

5º Agregamos el campo total.
	-En el form:
		<tr>
			<th>Nombre</th>
			<th>Precio</th>
			<th>Cantidad</th>
			<th>Total</th>
		</tr>	
	-En la plantilla-items:
				input type="number" value="1" name="cantidad[]" id="cantidad_{ID}" class="form-control col-sm-4" onchange="itemsHelper.calcularImporte({ID}, {PRECIO}, this.value);"/></td>		//Añadimos el onchange
				<td><span id="total_importe_{ID}">0</span></td>
			</tr>
		</tbody>
	-En el autocomplete-productos.html tneemos que añadir un itemHelper para poder hacer el calculo, eliminar items, si seleccionamos otro más que no lo añada abajo si no que sume la cantidad...:
		Añadimos para calcular ->
					$("#cargarItemProductos tbody").append(linea);
					itemsHelper.calcularImporte(ui.item.value, ui.item.precio, 1)	//Le pasamos el id con ui.item.value y el precio con lo otro
					
					return false;
					//Y abajo un metodo con el helper:
					var itemsHelper = {
						calcularImporte: function(id, precio, cantidad){
							$("#total_importe_" + id).html(parseInt(precio) * parseInt(cantidad));	//Tenemos esta variable en la plantilla en el span y con html agregamos contenido, en este caso la cantidad. 
						}
					}
					</script>

6º Evitar que cuando exista un producto cree una linea repetida, simplemente que se añada al ya existente en la cantidad, añadimos en el itemHelper el siguiente metodo:
				,
				hasProducto: function(id){		//Busca linea por linea si existe el ID del producto
					var resultado = false;
					$('input[name="item_id[]"]').each(function(){
						if(parseInt(id) == parseInt($(this).val()) ){
							resultado = true;
						}
					});
					return resultado;	
				},
				incrementaCantidad: function(id, precio){
					var cantidad = $("#cantidad_" + id).val() ? parseInt($("#cantidad_" + id).val()) : 0;
					$("#cantidad_" + id).val(++cantidad);
					this.calcularImporte(id, precio, cantidad)
				}
//Comprobamos en el select function que no exista antes de añadirlo, usando este metodo recien creado:
	select: function(event, ui){	//Se encarga de seleccionar ese valor y hacer alguna tarea
					$("#buscar_producto").val(ui.item.label);  //Pone la seleccion en el campo
					
					if(itemsHelper.hasProducto(ui.item.value)){
						itemsHelper.incrementaCantidad(ui.item.value, ui.item.precio);
						return false;
					}

7º Eliminar linea de la factura:
	//Añadimos el metodo en el itemHelper del autompletado.html
				,
				eliminarLineaFactura: function(id){
					$("#row_" + id).remove();
				}
	//En la plantilla-items.html añadimos la siguiente linea para mostrar el enlace de eliminar en la tabla:
	 <td><a href="#" class="btn btn-danger btn-xs" onclick="itemsHelper.eliminarLineaFactura({ID});">X</a></td>
	
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------ JOIN FETCH --------------------------------------------------------------------------------------------------------
//Es la mejor forma cuando trabajamos ocn un objeto entity con muchas relaciones
//Sirve para que en vez de hacer 7 consultas por ejemplo lo haga en una con JOIN FETCH, haciendo que el Dao obtenga la factura por ejemplo pero con todas las relaciones hechas en vez de realizar en la vista las consultas de forma perezosa con lazys para ver todas las relaciones.

1º En IFacturaDao incluimos el siguiente metodo indicando las relaciones para evitar que en la vista haga tantas consultas para llegar a la que necesita:
	public interface IFacturaDao extends CrudRepository<Factura, Long>{

		//Factura se une a cliente y a items directamente y luego a producto desde items factura, l es alias del itemfactura por lo tanto lo obtenemos desde ahi
		//cliente y producto son atributos de factura por eso se obtienen desde f.
		@Query("select f from Factura f join fetch f.cliente c join fetch f.items l join fetch l.producto where f.id =?1")
		public Factura fetchByIdWithClienteWithItemFacturaWithProducto(Long id); 
	}

2º Añadimos este metodo en la interfaz del IClienteService:
	public Factura fetchByIdWithClienteWithItemFacturaWithProducto(Long id);

3º Implementamos el metodo en la clase service:
	@Override
	@Transactional(readOnly = true)
	public Factura fetchByIdWithClienteWithItemFacturaWithProducto(Long id) {
		return facturaDao.fetchByIdWithClienteWithItemFacturaWithProducto(id);
	}

4º Lo ponemos en el controlador (en este caso modificamos FacturaController el metodo que ya teniamos) y cambiamos el anterior obtener la factura por el id por el nuevo, que hara menos consultas gracias a la mejora:

	@GetMapping("/ver/{id}")
	public String ver(@PathVariable(value="id") Long id, Model model, RedirectAttributes flash) {
		
		//Factura factura = clienteService.findFacturaById(id);
		
		Factura factura = clienteService.fetchByIdWithClienteWithItemFacturaWithProducto(id);
	
//EJEMPLO CON CLIENTE TRAYENDO SUS FACTURAS, en este caso por ejemplo si intentasemos meternos en un cliente sin facturas nos daria error al hacer el inner join y no tener facturas, aunque ese cliente si que exista, para solucionarlo debemos hacer left join.
	@Query("select c from Cliente c left join fetch c.facturas f where c.id = ?1")
	public Cliente fetchByIdWithFacturas(Long id);
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
